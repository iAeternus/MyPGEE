# 王道数据结构笔记

## 第一章 绪论

1. 逻辑结构（抽象） -- 一对多 -- 存储结构（具体）
2. 计算 $\pi$ 的算法有零个输入
3. 主定理：$T(n) = aT(n/b) + f(n)$
   * 若 $f(n) \ne n^{\log_b a}$，则 $T(n) = \Theta (max(f(n), n^{\log_b a}))$
   * 否则，$T(n) = \Theta(n^{\log_b a}log n)$
   * **不等取大，相等乘对数因子**

## 第二章 线性表

1. 线性表中：数据元素 -- 一对多 -- 数据项
   * 数据元素就是线性表里存的元素
   * 数据元素是由数据项组成的
2. 单链表逆置方法：摘下头结点，从首元开始，一次插入到头结点后面，直到最后一个节点为止
3. 取链表中点方法：设置快慢指针分别为 f 和 s，初始时均指向首元，之后 s 每次走一步，f 每次走两步。当 f 指向表尾时，s 正好指向链表中点
4. 有时候，可以将单链表的变成循环单链表来加速一些循环操作的问题，比如单链表循环位移

## 第三章 栈、队列和数组

1. 当 $n$ 个不同元素入栈时，出栈元素不同排列的个数为 $\frac{1}{n + 1}C_{2n}^n$
   * 组合计算公式：$C_{2n}^n = \frac{A_n^m}{n!}$

2. 一个存储单元 = 1 byte，地址 1000H + 1byte = 1001H
   * 1000H + 1KB = 1400H

3. C 语言标识符只能以英文字母或下划线开头，不能以数字开头

4. a b c d e 依次入栈，在所有可能的出栈序列中，以 d 开头的序列怎么求
   * d 之后入栈的只有 e
   * d 最先出栈，下面的只能按照 c b a 的顺序出栈
   * e 有可能插入到 c b a 之间的任意位置出栈
   * 故
     * d **e** c b a
     * d c **e** b a 
     * d c b **e** a
     * d c b a **e**

5. 循环队列首尾指针
   * 不管是队首指针指向首元的前驱还是队尾指针指向尾元的后继以牺牲一个单元来区分对空和队满，以下结论均成立
     * 判断队满：$(rear + 1) \% SIZE == front$
     * 判断队空：$front == rear$ // TODO 似乎存在错误
     * 求元素个数：$(rear - front + SIZE) \% SIZE$
   * 队尾指针指向首元的前驱，队首指针指向尾元：队尾指针需要初始化在数组末尾，即队尾指针 = n - 1
   * 队首指针指向首元的前驱，队尾指针指向尾元：队首指针需要初始化在数组末尾，即队首指针 = n - 1

6. 带尾指针的循环单链表最适合做链式队列

   * 尾删 O(n)，尾插、头插、头删 O(1)

7. 带头尾指针的单链表适合做链式队列

   * 尾删 O(n)，尾插、头插、头删 O(1)

8. | 名称 | 指针名 | 作用     |
   | ---- | ------ | :------- |
   | 队头 | front  | 弹出元素 |
   | 队尾 | rear   | 插入元素 |

   * **头删尾插**

9. 使用带头尾指针的单链表做链式队列时，删除操作可能头尾指针都要修改。因为当队列只有一个元素时，需要修改尾指针

10. 三元组表存储稀疏矩阵无法随机访问

11. 三对角矩阵公式推导

    ``` cpp
    第i - 1行：2 + (i - 2) * 3 // 2是第一行的两个，后面都是3个一行
    第i行    ：j - i + 2
    故 k = 2 + (i - 2) * 3 + j - i + 2 - 1 = 2i + j - 3 // 下标从0开始
       k = 2 + (i - 2) * 3 + j - i + 2 = 2i + j - 2 // 下标从1开始
    对于下标从0开始的情况
    i = (k + 1) / 3 + 1
    j = k - 2i + 3
    ```

12. 矩阵与压缩数组下标换算公式

    * 对称矩阵

    | 矩阵起点 | 数组起点 | 矩阵 → 数组公式                                              | 数组 → 矩阵公式                                              |
    | -------- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 0        | 0        | $k = \begin{cases} \frac{i(i+1)}{2} + j & i \geq j \\ \frac{j(j+1)}{2} + i & j > i \end{cases}$ | $ i = \left\lfloor \frac{\sqrt{8k + 1} - 1}{2} \right\rfloor $, $ j = k - \frac{i(i+1)}{2} $ |
    | 0        | 1        | $ k = \begin{cases} \frac{i(i+1)}{2} + j + 1 & i \geq j \\ \frac{j(j+1)}{2} + i + 1 & j > i \end{cases}$ | $ i = \left\lfloor \frac{\sqrt{8(k-1) + 1} - 1}{2} \right\rfloor $, $ j = (k-1) - \frac{i(i+1)}{2} $ |
    | 1        | 0        | $ k = \begin{cases} \frac{(i-1)i}{2} + j & i \geq j \\ \frac{(j-1)j}{2} + i & j > i \end{cases}$ | $ i = \left\lfloor \frac{\sqrt{8k + 1} - 1}{2} \right\rfloor + 1 $, $ j = k - \frac{(i-1)i}{2} $ |
    | 1        | 1        | $ k = \begin{cases} \frac{(i-1)i}{2} + j + 1 & i \geq j \\ \frac{(j-1)j}{2} + i + 1 & j > i \end{cases} $ | $ i = \left\lfloor \frac{\sqrt{8(k-1) + 1} - 1}{2} \right\rfloor + 1 $, $ j = (k-1) - \frac{(i-1)i}{2} $ |

    * 下三角矩阵

    | 矩阵起点 | 数组起点 | 矩阵 → 数组公式                                          | 数组 → 矩阵公式                                              |
    | -------- | -------- | -------------------------------------------------------- | ------------------------------------------------------------ |
    | 0        | 0        | $ k = \frac{i(i+1)}{2} + j $ (当且仅当 $ i \geq j $)     | $ i = \left\lfloor \frac{\sqrt{8k + 1} - 1}{2} \right\rfloor $, $ j = k - \frac{i(i+1)}{2} $ |
    | 0        | 1        | $ k = \frac{i(i+1)}{2} + j + 1 $ (当且仅当 $ i \geq j $) | $ i = \left\lfloor \frac{\sqrt{8(k-1) + 1} - 1}{2} \right\rfloor $, $ j = (k-1) - \frac{i(i+1)}{2} $ |
    | 1        | 0        | $ k = \frac{(i-1)i}{2} + j - 1 $ (当且仅当 $ i \geq j $) | $ i = \left\lfloor \frac{\sqrt{8k + 1} - 1}{2} \right\rfloor + 1 $, $ j = k - \frac{(i-1)i}{2} + 1 $ |
    | 1        | 1        | $ k = \frac{(i-1)i}{2} + j $ (当且仅当 $ i \geq j $)     | $ i = \left\lfloor \frac{\sqrt{8(k-1) + 1} - 1}{2} \right\rfloor + 1 $, $ j = (k-1) - \frac{(i-1)i}{2} + 1 $ |

    * 上三角矩阵

    | 矩阵起点 | 数组起点 | 矩阵 → 数组公式                                              | 数组 → 矩阵公式                                              |
    | -------- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 0        | 0        | $ k = \frac{n(n+1)}{2} - \frac{(n-i)(n-i+1)}{2} + j - i $ (当且仅当 $ j \geq i $) | $ i = n - \left\lfloor \frac{\sqrt{8(\frac{n(n+1)}{2} - k) + 1} - 1}{2} \right\rfloor $, $ j = k + i - \frac{n(n+1)}{2} + \frac{(n-i)(n-i+1)}{2} $ |
    | 0        | 1        | $ k = \frac{n(n+1)}{2} - \frac{(n-i)(n-i+1)}{2} + j - i + 1 $ (当且仅当 $ j \geq i $) | $ i = n - \left\lfloor \frac{\sqrt{8(\frac{n(n+1)}{2} - (k-1)) + 1} - 1}{2} \right\rfloor $, $ j = (k-1) + i - \frac{n(n+1)}{2} + \frac{(n-i)(n-i+1)}{2} $ |
    | 1        | 0        | $ k = \frac{(n-1)n}{2} - \frac{(n-i)(n-i+1)}{2} + j - i $ (当且仅当 $ j \geq i $) | $ i = n - \left\lfloor \frac{\sqrt{8(\frac{(n-1)n}{2} - k) + 1} - 1}{2} \right\rfloor + 1 $, $ j = k + i - \frac{(n-1)n}{2} + \frac{(n-i)(n-i+1)}{2} $ |
    | 1        | 1        | $ k = \frac{(n-1)n}{2} - \frac{(n-i)(n-i+1)}{2} + j - i + 1 $ (当且仅当 $ j \geq i $) | $ i = n - \left\lfloor \frac{\sqrt{8(\frac{(n-1)n}{2} - (k-1)) + 1} - 1}{2} \right\rfloor + 1 $, $ j = (k-1) + i - \frac{(n-1)n}{2} + \frac{(n-i)(n-i+1)}{2} $ |

    * 三对角矩阵

    | 矩阵起点 | 数组起点 | 矩阵 → 数组公式                                           | 数组 → 矩阵公式                                              |
    | -------- | -------- | --------------------------------------------------------- | ------------------------------------------------------------ |
    | 0        | 0        | $k = 3i + j - i$ (当且仅当 $j = i-1, i, i+1$)             | $i = \left\lfloor \frac{k}{3} \right\rfloor$, $j = k \% 3 + i - 1$ |
    | 0        | 1        | $k = 3i + j - i + 1$ (当且仅当 $j = i-1, i, i+1$)         | $i = \left\lfloor \frac{k-1}{3} \right\rfloor$, $j = (k-1) \% 3 + i - 1$ |
    | 1        | 0        | $k = 3(i-1) + j - (i-1)$ (当且仅当 $j = i-1, i, i+1$)     | $i = \left\lfloor \frac{k}{3} \right\rfloor + 1$, $j = k \% 3 + (i-1) - 1$ |
    | 1        | 1        | $k = 3(i-1) + j - (i-1) + 1$ (当且仅当 $j = i-1, i, i+1$) | $i = \left\lfloor \frac{k-1}{3} \right\rfloor + 1$, $j = (k-1) \% 3 + (i-1) - 1$ |

    * 行优先与列优先的区别为 `i` 与 `j` 互换

13. 二维矩阵 $A[i][i]$ 与 $A[i-k][i-k]$ 之间的内存距离为常数 $d = k * (m + 1) * L$

    * $k$ 为行和列的偏移量，$m$ 为矩阵列数，$L$ 为每个元素占用的内存大小
    * 下标从 0 开始、下标从 1 开始、矩阵行列不等时该公式均试用

14. 下标从 0 开始时，下标值表示该元素前面的元素个数；下标从 1 开始时，下标值减 1 表示该元素前面的元素个数。

## 第四章 串

1. KMP 求 next 数组
   * next 数组表示模式串中最长相等前后缀的长度（对于一对相等的前后缀，不一定是回文，前后缀顺序相等）
   * 若模式串下标从 0 开始：next 数组首元为 0，数最长相等前后缀的长度即可
     * 注意，这种只在代码里写
   * 若模式串下标从 1 开始：先求下标从 0 开始的 next 数组，再将 next 数组整体加 **1**，整体右移 **1** 位 ，首元补 **0**
     * 此时模式串的下标为 1 和 2 的元素一定分别为 0 和 1
     * 这种情况考研常考
     * 考题中若模式串下标从 0 开始，先按代码中的方法求下标从 0 开始的 next 数组，然后整体右移 **1** 位，首元补 **-1**
     * 考题中若看到 next 数组首元为-1，说明题设下标从 0 开始；若首元为 0，说明题设下标从 1 开始
2. KMP 求比较次数
   * 失配了的那次比较也算
3. KMP 模式串最大滑动距离
   * 不给主串，一律认为模式串匹配到最后一个字符时失配并且该字符在模式串中不存在，直接跳到模式串开头
   * $最大距离 = 模式串长度 - 1$

## 第五章 树与二叉树

### 树

* $n$： 树的节点数
* $n_i$： 度为 $i$ 的节点数
* $n_0$：为 0 的节点个数/叶结点个数
* $m$： 树的度
* $h$：树的高度

1. $n = \sum_1^m in_i + 1 = \sum_0^m n_i = n_0 + \sum_1^m n_i$
2. 对于一颗满 $m$ 叉树，第 $i$ 层有 $m^{i-1}$ 个节点，到第 $i$ 层为止共有 $\frac{m^i - 1}{m - 1}$
3. $n_0 = \sum_2^m (i - 1) n_i + 1$
4. $h$ 的取值范围为 $\lceil log_m{n(m - 1) + 1} \rceil \le h \le n - m + 1$

### 二叉树

* $n$：二叉树节点数
* $n_0$： 度为 0 的节点个数/叶结点个数
* $n_2$：度为 2 的节点个数/分支节点个数
* $h$：树的高度

1. 非空二叉树：

   $n_0 = n_2 + 1$，$n = n_0 + n_1 + n_2$

   第 $k$ 层最多有 $2^{k - 1}$ 个节点

   整个树一共最多有 $2^h - 1$ 个节点

2. 完全二叉树：

   $h = \lfloor log_2 n \rfloor + 1 = \lceil log_2 (n + 1) \rceil$

3. 有 $n$ 个节点的二叉树采用链式存储，空指针数为 $n + 1$


### 二叉树的遍历

1. 已知先序、中序构造二叉树；已知后序、中序构造二叉树

   > 注：
   >
   > 1. 连线的时候不能跨节点（对上面的节点做一条铅垂线，下面的连线不能跨过该铅垂线）
   > 2. 中序写下面写上面无所谓
   > 3. 构造完成后必须检查一遍，检验遍历顺序是否符合题目要求
   > 4. 如果实在不能使用这个方法，那先序就从头看起，二分中序序列；后序从尾看起，二分中序序列

   ![反向构建二叉树](assets\反向构建二叉树.jpg)

2. 已知层序、中序构造二叉树

   ![层序中序构造二叉树](assets\层序中序构造二叉树.jpg)

3. 先序、后序和层序两两组合无法唯一确定一棵二叉树

